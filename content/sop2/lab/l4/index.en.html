---
title: "Tutorial 8 - Sockets, threads, shared memory, synchronization"
date: 2022-02-01T20:03:50+01:00
draft: false
---

<div class="dlaN">
<h3>How to prepare for the labs?</h3>
<p>POSIX synchronization is the primary subject of this lab, please expect the elements already practiced especially threads, network sockets and shared memory. Only conditional variables and POSIX semaphores are new in this tutorial. You may also find a POSIX barrier useful (it is not covered here but very simple to use). The last test in this semester is mostly about practicing what you already know (network sockets, select function).</p>

<p>For entry test and the task please read all the materials listed below. You do not need to read all the content of the man pages listed, it is enough to know the purpose of the function, what parameters does it take (roughly, do not memorize all the parameters), if it has flags how they affect the outcome. Full man page invocations (execute it in the console) are listed. <em>Preparation references from previous tutorial are still obligatory!</em><ul>
<li>man 3p pthread_cond_destroy (also _init and macro initialization)</li>
<li>man 3p pthread_cond_timedwait (also _wait)</li>
<li>man 3p pthread_cond_broadcast (also _signal)</li>
<li>man 3p pthread_barrier_destroy (also _init and macro initialization) </li>
<li>man 3p pthread_barrier_wait</li>
<li>man 3p sem_init</li>
<li>man 3p sem_open</li>
<li>man 3p sem_trywait (also _wait)</li>
<li>man 3p sem_post</li>
<li>man 3p sem_close</li>
<li>man 3p sem_destroy</li>
</ul></p>
</div><hr/ >

           Agenda:
                                <ol>
                                    <li><a href="#task_zad1">Task 1 - POSIX semaphores</a></li>
                                    <li><a href="#task_zad2">Task 2 - conditional variable</a></li>
                                </ol>
 <hr />
<h3 id="task_zad1">The alarm - semaphores</h3>
<p>Write a multi-threaded udp timer server and simple udp client. Client sends
number of seconds it needs to be counted to the server and awaits server
response. Server starts separate thread for each new request. The thread sleeps
for given time and sends the same time as a response. Then the thread exits.
Upon response arrival client prints the message "TIME has expired" and exits.
In case of udp packet disappearance client has additional timeout of 15
seconds. On timeout client prints "TIMEOUT" and exits.</p>

<p>Server has a limit of 10 concurrent threads. If it receives more
requests, client is sent immediate response (-1). On such a response the
client prints "Service Denied" and exits. </p>

<p>Server uses only one socket, datagrams are formated as int16_t, limit on
concurrent threads can be imposed with POSIX semaphore.</p>


<em>Solution: <b>server.c</b></em>
<pre>{{% include "server.c" %}}</pre>

<em>Solution: <b>client.c</b></em>
<pre>{{% include "client.c" %}}</pre>
<div class="dlaN"><ol>
<li>Network, thread or mutex aspects of the above long code will not be discussed here, please refer to the previous tutorials (also in OPS1). Here we will only cover semaphores.</li>
<li>Semaphores (like mutexes) can not be copied, you can only use pointers to pass them to the functions, also to the thread function.</li>
<li>Please notice that you can only use post, wait (or timedwait, trywait) operations to implement the synchronization on semaphore. The value you get from sem_getvalue is prone to change. It can change right after your code gets it and making any synchronization decision based on it is not acceptable!</li>
<li>This code includes signals processing both in server and the client, it is essential to protect vulnerable functions from geting interrupted. </li>
<li>Please notice that the UDP socket is shared without any synchronization between the threads. Do not expect any side effects of this as datagrams transfer is atomic by its nature.</li>
</ol></div>
<div class="cwiczenie"><ol>
<li>It is worth of your time to analyze the above code in aspects not covered here (network, thread,mutex), please do it as an exercise.</li>
<li>Why it is necessary to allocate memory before we start the thread, can this be avoided?<br/>
{{< answer >}} One common structure is not enough as each thread has to have its own, you can have an array of structures (FS_NUM sized) but then you need to  manage this array in the way you manage memory so it is easier to allocate a structure on a heap. Naturally this memory has to be released somewhere, in this case, in the thread itself. {{< /answer >}}</li>
<li>Where client timer is executed?</br>
{{< answer >}} In the working thread, time counting is the reason we create the thread. {{< /answer >}}</li>
<li>What is the semaphore used for?</br>
{{< answer >}} It keeps the count of threads that can still be started without exceeding  FS_NUM. Initially its value is set to 10 and before creating next thread it must be decreased by one. Zero value blocks the creation of the threads. Before the thread terminates it increases the semaphore by one. {{< /answer >}}</li>
<li>Why sem_trywait is used not just sem_wait before the new thread is created? What if we use sem_wait instead? <br/>
{{< answer >}} We need to know that we reached the thread limit immediately so we can send deny message to the client. With blocking wait server would wait until one of the threads finishes and increases the semaphore but it would mean longer alarm span than requested by the client! {{< /answer >}}</li>
<li>What limits the concurrent connections to 10 on the server?</br>
{{< answer >}} Semaphore, see two questions above. {{< /answer >}}</li>
</ol></div>
<h3 id="task_zad2">Threads pool - conditional variables</h3>
<p>Task author: <b>Jerzy Bartuszek</b></p>

<p>Write a simple file sharing server. Server's purpose is to serve content of
files placed in a given directory. Each client sends name of a file and in
return the server sends back the file's content. Server is a multi-threaded
application - each client's request is being handled in a separate thread.
Server creates THREADS_NUM threads in advance and keeps idle threads in a
thread pool. After receiving SIGINT server stops accepting incoming connections
and terminates its execution after handling all current requests.</p>

<p>Client waits for user's input - a single file name, sends it to the server and awaits the response that is printed on the screen. Then it exits.</p>

<p>Client and server communicate using remote TCP connection. We can assume that
size of a single file does not exceed 500 bytes and its name is no longer than
30 characters.</p>

<em>Solution: <b>server2.c</b></em>
<pre>{{% include "server2.c" %}}</pre>
<em>Solution: <b>client2.c</b></em>
<pre>{{% include "client2.c" %}}</pre>
<div class="dlaN"><ol>
<li>Network, thread or mutex aspects of the above long code will not be discussed here, please refer to the previous tutorials (also in OPS1). Here we will only cover conditional variable.</li>
<li>This code does not handle signals but code protection against interruption is added to extend portability.</li>
</ol></div>
<div class="cwiczenie"><ol>
<li>It is worth of your time to analyze the above code in aspects not covered here (network, thread,mutex), please do it as an exercise.</li>
<li>Can a condition of conditional variable be based on regular variable value?<br>
{{< answer >}} Yes. {{< /answer >}}</li>
<li>Can a condition of conditional variable be based on a combination of regular variables' values?<br>
{{< answer >}} Yes. {{< /answer >}}</li>
<li>Can a condition of conditional variable be based on file content?<br>
{{< answer >}} Yes. {{< /answer >}}</li>
<li>Can a condition of conditional variable be based on file existence?<br>
{{< answer >}} Yes. {{< /answer >}}</li>
<li>What are the limitations for the condition of conditional variable?<br>
{{< answer >}} Everything you can code that will return true or false, coder imagination defines the limit. {{< /answer >}}</li>
<li>Can we use conditional variable without any condition at all?<br>
{{< answer >}} Yes. it will become a pool of threads waiting for wakening as you need. {{< /answer >}}</li>
<li>Conditional variable must have a mutex, what is protected by it?<br>
{{< answer >}} Mutex protects the access to the elements (variables,files) used in the variable condition so it remains unchanged when the code tests the condition. You must acquire the mutext prior to changing the state of those elements and prior to condition testing. {{< /answer >}}</li>
<li>Can one mutex protect multiple conditional variables?<br>
{{< answer >}} It can, but please consider the efficiency and parallelism of your code, it will be lowered. {{< /answer >}}</li>

<li>What are the parts of the condition for the conditional variable in the above code?<br>
{{< answer >}} The condition is solely based on the variable called "condition", all threads have access to this variable via pointers. {{< /answer >}}</li>
<li>How does the conditional variable works in this program?<br>
{{< answer >}} When main thread accepts a new connection it sets the "condition" variable to 1 and wakes one of waiting (waiting for the condition) threads. The thread that wakes, checks for "condition==1" and if it is true it handles the connection. {{< /answer >}}</li>
<li>Who should check for the condition to be true? The thread that wakes or maybe the one that is being wakened?<br>
{{< answer >}}  The condition must be always checked by the thread being wakened. Even if the one that wakes checked it before it could have changed in meantime as the mutex was released and could have been acquired by some other thread to invalidate the condition! Generally it is better if the condition is checked also before signaling but sometimes it is not possible as wakening thread may not have access to all the condition components. {{< /answer >}}</li>
<li>What is cleanup handler in working thread used for?<br>
{{< answer >}} It is essential not to end the working thread without releasing the mutext that blocks the conditional (it would freeze entire program) . This handler releases the mutex in case of emergency exit. {{< /answer >}}</li>

</ol></div>

<hr/>
<p class="cwiczenie">
As an exercise do <a href="{{< ref "../l4-example" >}}">this</a> task. It was used in previous years. It is 90 minutes task and if you can do it in this time it means you are well prepared for the lab. 
</p>

<h2>Source codes presented in this tutorial</h2>

{{% codeattachments %}}
