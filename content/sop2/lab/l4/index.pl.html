---
title: "Tutorial 8 - Gniazda, wątki, pamięć wspólna, synchronizacja "
date: 2022-02-01T20:03:50+01:00
draft: false
---

<div class="dlaN">
<h3>Jak się przygotować do zajęć?</h3>
<p>Tematem przewodnim zajęć jest synchronizacja POSIX ale samo zadanie będzie oparte także o elementy już wcześniej przez Państwa ćwiczone, na pewno pojawią się wątki i gniazda sieciowe a także pamięć wspólna.To co jest nowe w tym materiale to zmienne warunkowe i semafory POSIX, w zadaniu może się także pojawić bardzo prosta w użyciu bariera (nie ma jej w przykładach). Ostatnie sprawdzane zadanie SOP2 ma charakter w dużym stopniu powtórzeniowy (gniazda sieciowe i select), nowego materiału jest mało.</p>

<p>Do wejściówki i zadania proszę zapoznać się z materiałami podanymi poniżej, nie czytgamy całości stron man ale tylko tyle aby wiedzieć co dana funkcja robi, jakie z grubsza przyjmuję parametry i jeśli ma flagi to jak one zmieniają jej działanie. <em>Materiały przygotowawcze z poprzednich zajęć nadal obowiązują!</em>
Podane zostały całe polecenia man do wydania z konsoli:<ul>
<li>man 3p pthread_cond_destroy (także _init i statyczna deklaracja)</li>
<li>man 3p pthread_cond_timedwait (także _wait)</li>
<li>man 3p pthread_cond_broadcast (także _signal)</li>
<li>man 3p pthread_barrier_destroy (także _init i  statyczna deklaracja) </li>
<li>man 3p pthread_barrier_wait</li>
<li>man 3p sem_init</li>
<li>man 3p sem_open</li>
<li>man 3p sem_trywait (także _wait)</li>
<li>man 3p sem_post</li>
<li>man 3p sem_close</li>
<li>man 3p sem_destroy</li>
</ul></p></li>
</div>
<h2>Agenda</h2>
                                <ol>
                                    <li><a href="#task_zad1">Zadanie 1 - semafory POSIX</a></li>
                                    <li><a href="#task_zad2">Zadanie 2 - zmienna warunkowa</a></li>
                                </ol>
                                <hr />
<h3 id="task_zad1">Budzik - semafory</h3>
<p>Napisz prosty wielowątkowy serwer czasu wraz z klientem, komunikacja ma odbywać się poprzez UDP w domenie INET. Klient wysyła za ile sekund chce aby serwer go powiadomił po czym czeka na "budzenie" z serwera (które powinna nastąpić w miarę dokładnie po tylu sekundach ile sobie zażyczył). Serwer dla każdego zapytania uruchamia oddzielny wątek, który odmierza czas i udziela odpowiedzi. Klient po otrzymaniu odpowiedzi wyświetla stosowny komunikat i się kończy. Jeśli odpowiedź nie nadejdzie to klient ma mieć własny mechanizm timeout'u awaryjnego, który jeśli zadziała ma skutkować komunikatem TIMEOUT i zakończeniem programu.</p>

<p>Serwer ma mieć limit 10 aktywnych klientów, jeśli podłączy się 11ty to ma dostać natychmiast specjalną wiadomość o braku zasobów. Limit ma być zaimplementowany na semaforze. Wolno użyć tylko jednego gniazda UDP po stronie serwera, wszystkie datagramy maja składać się wyłącznie z jednej liczby typu int16_t.</p>

<em>Rozwiązanie: <b>server.c</b></em>
<pre>{{< include "server.c" >}}</pre>

<em>Rozwiązanie: <b>client.c</b></em>
<pre>{{< include "client.c" >}}</pre>
<div class="dlaN"><ol>
<li>Powyższy długi kod nie będzie tu komentowany pod kątem wątków, muteksów czy też gniazd sieciowych. Odpowiednie materiały znajdziecie w poprzednich tutorialach (także tych z SOP1). Tutaj skupimy się tylko na semaforach.</li>
<li>Semafory, podobnie jak muteksy, przekazujemy do funkcji (też do wątków) tylko poprzez wskaźnik, kopia semafora nie jest semaforem!</li>
<li>Do implementowania logiki programu na semaforze używamy tylko operacji post i wait (timedwait, trywait) nigdy sem_getvalue gdyż wartość otrzymana z tej ostatniej funkcji mogła się zmienić tuż po odczycie czyli już w momencie jej analizy nie jest ona aktualna!</li>
<li>W tym kodzie występuje obsługa sygnałów, zarówno w kliencie jak i w serwerze, ochrona kodu przed przerwaniem jest zatem niezbędna.</li>
<li>Zwróć uwagę na dostęp do gniazda UDP, jest swobodnie współdzielony pomiędzy wątkami, wysyłanie i odbiór datagramów jest atomowe więc nie spodziewamy się problemów.</li>
</ol></div>
<div class="cwiczenie"><ol>
<li>Warto samemu dokonać dokładnej analizy powyższego kodu pod kątem elementów nie omawianych tutaj, proszę to zrobić jako ćwiczenie.</li>
<li>Czemu przed uruchomieniem wątku w serwerze alokujemy pamięć? Czy można się tej alokacji pozbyć z kodu?<br/>
{{< answer >}} Nie możemy użyć jednej wspólnej struktury bo na raz może być więcej niż jeden wątek roboczy. Można zrobić tablice FS_NUM struktur ale  trzeba by wtedy zarządzać wolnymi polami w tej tablicy a to oznacza trochę więcej kodu. Najłatwiej jest zaalokować pamięć dla tej struktury przed uruchomieniem wątku. Pamiętamy o zwolnieniu tej pamięci w wątku zanim się skończy. {{< /answer >}}</li>
<li>Gdzie jest odliczany czas dla klienta?</br>
{{< answer >}} W wątku roboczym, w tym celu go tworzymy. {{< /answer >}}</li>
<li>Czemu służy semafor?</br>
{{< answer >}} Semafor odlicza ile jeszcze wątków można utworzyć aby na raz nie działało ich więcej niż FS_NUM (10). Na początek jego wartość to 10, przed utworzeniem kolejnego wątku zmniejszamy wartość semafora. Zanim wątek skończy zwiększa tą wartość. Jeśli wartość semafora jest zerowa to nie da się już utworzyć kolejnego wątku. {{< /answer >}}</li>
<li>Czemu przed utworzeniem kolejnego wątku roboczego w serwerze używamy sem_trywait? Co się stanie gdy zamienimy to na sem_wait?<br/>
{{< answer >}} Robimy tak, aby od razu zorientować się, że wyczerpaliśmy limit wątków. Gdyby zastąpić trywait wait'em to program poczekałby aż się zwolni jakiś wątek i dopiero wtedy zarejestrował klienta, ale to oznacza, że czas odliczony dla tego klienta byłby dłuższy niż on żądał! {{< /answer >}}</li>
<li>Co powoduje limitowanie połączeń do 10 naraz?</br>
{{< answer >}} Semafor, zerknij na 2 powyższe pytania i odpowiedzi. {{< /answer >}}</li>
</ol></div>
<h3 id="task_zad2">Pula wątków - zmienne warunkowe</h3>
<p>Autor zadania: <b>Jerzy Bartuszek</b></p>
<p>Napisz aplikację serwującą zawartość plików w zadanym katalogu. Klient przesyła nazwę pliku a serwer w odpowiedzi przesyła jego zawartość. Serwer ma być programem wielowątkowym. Do obsłużenia każdego zapytania jest delegowany wątek. Na początku działania serwer ma utworzyć pulę THREADS_NUM wątków i w miarę  przychodzenia zapytań delegować je do ich obsługi. Po otrzymaniu SIGINT serwer ma przestać przyjmować zlecenia i zaczekać na zakończenie tych, które są w trakcie  przez zakończeniem się.</p>
<p>Klient po uruchomieniu oczekuje na wejście z stdin (nawę pliku), przesyła ją do serwera i odbiera wynik, który następnie wyświetla na ekran po czym się kończy.</p>
<p>Klient z serwerem komunikuje się poprzez połączenie TCP , zakładamy, że rozmiary plików nie przekraczają 500 bajtów a nazwy plików nie przekraczają 30 znaków.</p>
<em>Rozwiązanie: <b>server2.c</b></em>
<pre>{{< include "server2.c" >}}</pre>
<em>Rozwiązanie: <b>client2.c</b></em>
<pre>{{< include "client2.c" >}}</pre>
<div class="dlaN"><ol>
<li>Powyższy długi kod nie będzie tu komentowany pod kątem wątków, muteksów czy też gniazd sieciowych. Odpowiednie materiały znajdziecie w poprzednich tutorialach (także tych z SOP1). Tutaj skupimy się tylko na zmiennej warunkowej.</li>
<li>W kodzie klienta i wątkach roboczych serwera nie występują sygnały ale ochrona przed przerwaniem sygnałem jest zapewniona także w tym kodzie dla większej przenośności kodu.</li>
</ol></div>
<div class="cwiczenie"><ol>
<li>Warto samemu dokonać dokładnej analizy powyższego kodu pod kątem elementów nie omawianych tutaj, proszę to zrobić jako ćwiczenie.</li>
<li>Czy warunek dla zmiennej warunkowej może być oparty o jedną zwykłą zmienna?<br>
{{< answer >}} Tak {{< /answer >}}</li>
<li>Czy warunek dla zmiennej warunkowej może być oparty na wartościach kilku zmiennych w programie?<br>
{{< answer >}} Tak {{< /answer >}}</li>
<li>Czy warunek dla zmiennej warunkowej może być oparty na zawartości pliku?<br>
{{< answer >}} Tak {{< /answer >}}</li>
<li>Czy warunek dla zmiennej warunkowej może być oparty na istnieniu pliku?<br>
{{< answer >}} Tak {{< /answer >}}</li>
<li>Jak można ogólnie określić na czym może być oparty warunek zmiennej warunkowej?<br>
{{< answer >}} Warunek może być absolutnie dowolny, to kod napisany przez programistę o tym decyduję więc granicą tego czym może być warunek jest tylko wyobraźnia kodującego. {{< /answer >}}</li>
<li>Czy zmienna warunkowa może być użyta bez żadnego warunku?<br>
{{< answer >}} Tak, jest wtedy zwykłą pulą czekających wątków które możemy wybudzać pojedynczo lub wszystkie naraz. {{< /answer >}}</li>
<li>Co chroni muteks związany z zmienną warunkowa?<br>
{{< answer >}} Muteks ma chronić dostęp do tych elementów programu (zmiennych, plików itd.) które są testowane w warunku zmiennej warunkowej. Chodzi o to, aby w czasie sprawdzania warunku zmiennej (zablokowania muteksu) mieć pewność, że warunek ten nie zostanie zmodyfikowany. {{< /answer >}}</li>
<li>Czy jeden muteks może chronić więcej niż jedną zmienna warunkową?<br>
{{< answer >}} Może, ale proszę pamiętaj o wydajności programu, takie rozwiązanie ograniczy też równoległość. {{< /answer >}}</li>
<li>Co wchodzi w skład zmiennej warunkowej w powyższym programie?<br>
{{< answer >}} Warunek jest oparty wyłącznie o zmienną "condition", do której wątki mają dostęp poprzez wskaźniki. {{< /answer >}}</li>
<li>Jak działa warunek zmiennej w tym programie?<br>
{{< answer >}} Gdy główny przyjmie nowe połączenie ustawia zamienną "condition" na 1 i budzi jeden z wątków czekających. Obudzony wątek jeśli widzi, że  "condition==1" to obsługuje połączenie. {{< /answer >}}</li>
<li>Który wątek powinien sprawdzić, że warunek zmiennej jest spełniony? Budzący czy obudzony?<br>
{{< answer >}} Warunek musi zawsze być sprawdzony przez wątek budzony, nie ma gwarancji że będzie on spełniony nawet jeśli wątek budzący go sprawdzał ponieważ muteks który blokuje zmianę warunku musi być na chwilę zwolniony pomiędzy wysłaniem prośby o obudzenie a samym obudzeniem. Jeśli w tym czasie muteks zostałby przejęty przez inny wątek to warunek może ulec zmianie! Dobrze jeśli wątek budzący sprawdzi warunek ale jeśli nie może tego zrobić bo nie ma dostępu do wszystkich składowych warunku to można ten krok pominąć. {{< /answer >}}</li>
<li>Czemu służy cleanup handler w wątku roboczym serwera?<br>
{{< answer >}} Bardzo ważne jest, aby wątek nie zakończył się nie zwolniwszy muteksu chroniącego zmienna warunkową, to zablokowałoby całą aplikację. Ten handler w razie awaryjnego wyjścia zwolni muteks. {{< /answer >}}</li>

</ol></div>

<h2>Przykładowe zadanie</h2>
<p class="cwiczenie">
Wykonaj przykładowe <a href="{{< ref "../l4-example" >}}">ćwiczenie</a> z poprzednich lat. To zadanie szacuję na 90 minut, jeśli wyrobisz się w tym czasie to znaczy, że jesteś dobrze przygotowany/a  do zajęć.  Możesz się spodziewać zadania o zbliżonej pracochłonności.
</p>

<h2>Kody źródłowe z treści tutoriala</h2>
{{% codeattachments %}}
