---
title: "Tutorial SOP2 Lab2: POSIX queues"
date: 2022-02-10T10:00:00+01:00
draft: false
layout: single
---

{{< codegrading >}}

<div class="dlaN">
<p>POSIX queues topic is significantly easier that links topic, so  this tutorial is shorter. Queues have message boundaries, can share access on read and write ends, can transfer large amounts of data in atomic way and add priorities to the  messages.  All that makes them easier to use. They have one useful feature that requires some understanding - notifications. Fortunately the API of the notification is identical to AIO notifications.</p>
<p>We expect more self studding from you,  please read lecture materials and man pages in addition to this page.</p>
<hr/ >
<h3>How to prepare for the labs?</h3>
<p>POSIX queue is the primary subject of this lab, please expect the elements already practiced especially threads, processes and signals. Due to identical notification methods AIO topic may be worth some of your attention (OPS1 L4).</p>

<p>For entry test and the task please read all the materials listed below. You do not need to read all the content of the man pages listed, it is enough to know the purpose of the function, what parameters does it take (roughly, do not memorize all the parameters), if it has flags how they affect the outcome. Full man page invocations (execute it in the console) are listed. <em>Preparation references from previous tutorial are still obligatory!</em><ul>
<li>man 7 mq_overwiev</li>
<li>man 3p mq_open</li>
<li>man 3p mq_close</li>
<li>man 3p mq_unlink</li>
<li>man 3p mq_getattr</li>
<li>man 3p mq_setattr</li>
<li>man 3p mq_send</li>
<li>man 3p mq_receive</li>
<li>man 3p mq_notify</li>
<li>man 7  sigevent - asynchronous notification on queue messages is identical as for AIO</li>
<li><b>POSIX queues require linking with librt!!!</b></li>
<li>If you open existing queue you can expect some data in it. Do not assume it will be empty! If you need to make it empty you can remove the queue before you create it again.</li>
</ul></p>
</div>
<hr/ >
<h3>Bingo!</h3>
<p>Write a program that will simulate simple variant of BINGO game. It features processes (parent and children) and two message queues. Parent process creates n sub-processes (0&lt;n&lt;100, n is a parameter) and two message queues. First one <em>pout</em> is used by parent to send random numbers (range [0-9]) to children at 1sec intervals. The second one <em>pin</em> is for children to communicate their winnings and exits. Children compete over the numbers from <em>pout</em> -  one digit goes to only one child (not all of them). Sub-process reads the digit from the queue, compare it to its expected number (random number <em>E</em> chosen at the start) and if they match send a special "BINGO" message via second queue <em>pin</em> along with the winning number. After "bingo" it terminates. Each child process must choose random limit of numbers it is going to read from the queue and compare. Once the limit is reached without "bingo" it sends a special "GOODBYE" message via second queue <em>pin</em> along with the terminating process number (its <em>n</em> number) and terminates. Parent process must asynchronously to sending numbers read the messages on the second queue (<em>pin</em>) and display proper information on the screen. Once all child processes are terminated parent process removes the queues and exits. <b>Single message size is limited to 1 byte only!</b></p>

<p>
<em>Solution: <b>mq_example.c</b></em>
<pre>{{% include "mq_example.c" %}}</pre>
<p>
<div class="dlaN"><ol>
<li>Please notice that sending a pointer along with the signal requires slightly different signal handling function prototype (it has additional siginfo_t* parameter) and during the installation  SA_SIGINFO flag was set. In this program we do not send this pointer directly (notification does it for us), function <em>kill</em> does not allow for any extra data, to send signal with a pointer (or a integer) you need to use <em>sigqueue</em> function.</li>
<li>In code uint8_t type (stdint.h) was used, it can hold  unsigned number form 0-255 range (one byte). Precise integer types (e.g. int32_t) are more portable between different architectures and compilers than traditional size unspecified types (like int). Type int can be stored on 2 or 4 bytes, long long type can be 4 bytes on 32 bytes Linux and 8 bytes on 64 bytes Linux. Type int32_t is always stored on 4 bytes. </li>
<li>This program handles signals thus proper restarting of uninterruptible functions in required. It is done with macro TEMP_FAILURE_RETRY added in almost all code despite the fact that only parent process is handling the signals as it receives the notifications.  Macros added in child slow down the code just a bit but also make the code more portable (also more reusable in students works).</li>
<li>Notification set on a queue are single use only i.e. after one notification you must request another one if you wish to keep monitoring the queue. The notification is triggered only if the empty queue becomes non empty. Only one process can be registered for the notification on the queue.</li>
</ol>
</div>
<div class="cwiczenie"><ol>
<li>In parent process one uninterruptible function call is not restarted, which one? Why this restarting in not required?<br/>
{{< answer >}} It is mq_receive in signal handling function. we do not expect the  interruption as by default signal being handled is blocked in the process for the duration of the signal handler. {{< /answer >}}</li>
<li>How this code counts the terminated child processes?<br/>
{{< answer >}} The code counts successful waitpid calls in SIGCHLD handler, you should not count the signals as they can marge. The counter of currently "alive" child processes is a global variable. {{< /answer >}}</li>
<li>When notification signal is handled first we request another notification and then we read data from the queue, why not the other way around?<br/>
{{< answer >}} If you do it in the reverse order then after you read all the messages from the queue and just before you request for another notification something may be delivered to the queue. If that happens and you request for the notification while the queue is not empty then you will not be notified until somehow the queue gets empty and after that not empty again. In this code nothing is reading the queue without the notification, this program will stall, no notification will be ever sent again! The sequence coded in this example is the right one. We set the notification on non empty queue, then we empty it. Now if something arrives in the queue then we get the notification. {{< /answer >}}</li>
<li>Why one of the queues is in non blocking mode?<br/>
{{< answer >}} The pin queues is in non blocking mode due to the above explanation. If we would block on reading in the signal handling function it would block a whole process (parent would stop sending the numbers on pout queue). Blocking in asynchronous signal handler is a huge flaw of the code. {{< /answer >}}</li>
<li>How queue messages priorities are used in this program, how it is related to the 1 byte message limit?<br/>
{{< answer >}} In this code priorities are not used to order the receive but as message types. We are forced to do it as we have only one byte for the information sent in the queue and we need to know the number and what this number represents (bingo number or exiting process number). It is easier to use priorities than encode it all in one byte. {{< /answer >}}</li>
<li>As an exercise modify this code to start a thread for notification.</li>
<li>You can simplify the program by crating a thread dedicated to read all the messages from the queue, no notifications will be used then. Please do this as an exercise</li>
<li>A huge part of programs logic ended up in signal handler, it is possible as this part does not have any common state (variables) with the rest of the program. What if we complicate it a bit and need some common variables? Can you change the program in such a way that all logic is in the main code and signal handler is limited only to a very simple global variable change? Do it as an exercise.</li>
</ol>
</div>
</p>
<hr/>
<p class="cwiczenie">
As an exercise do <a href="{{< ref "../l2-example" >}}">this</a> task. It was used in previous years. It is 90 minutes task and if you can do it in this time it means you are well prepared for the lab. 
</p>

<h2>Source codes presented in this tutorial</h2>

{{% codeattachments %}}
